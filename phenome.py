import os
import xml.etree.ElementTree as ET
import random
import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim

from constants import GeneDesc, Limits
from helpers.math_functions import normalize


class FingersPhenome:
    '''
    Phenotype description for the fingers.
    This is where encoded genetic information is modified to suit the traits we want
    the fingers to have. For example, each phalanx will be connected at the end of its parent. This
    class handles that modification.

    Args:
        genome_data: random genome generated by Genome class
        gene_description: GeneDesc enum class
        robot_hand_file: the base robot hand where dimensions for the palm are taken
    '''

    def __init__(self, genome_data, gene_description, robot_hand_file):
        self.genome_data = genome_data
        self.gene_desc = gene_description
        self.robot_hand_file = robot_hand_file

    def get_genome(self):
        '''Returns a modified fingers genome matrix'''
        self.__set_link_dimensions()
        self.__set_joint_origin()

        return self.genome_data

    def __set_link_dimensions(self):
        '''
        Limit the lower and upper dimensions of the phalanx.
        Takes the values from predefined constants.
        '''
        for i in range(len(self.genome_data)):  # loop through fingers
            finger = self.genome_data[i]

            if np.all(finger == 0):
                # No need to continue looping as the rest of array elements will be zero
                break

            for j in range(len(finger)):  # loop through phalanges
                phalanx = self.genome_data[i][j]

                if np.all(phalanx == 0):
                    break

                assert len(phalanx) == len(GeneDesc)

                phalanx[GeneDesc.DIM_X] = normalize(
                    phalanx[GeneDesc.DIM_X], Limits.DIM_X_LOWER, Limits.DIM_X_UPPER
                )
                phalanx[GeneDesc.DIM_Y] = normalize(
                    phalanx[GeneDesc.DIM_Y], Limits.DIM_Y_LOWER, Limits.DIM_Y_UPPER
                )
                phalanx[GeneDesc.DIM_Z] = normalize(
                    phalanx[GeneDesc.DIM_Z], Limits.DIM_Z_LOWER, Limits.DIM_Z_UPPER
                )

    def __set_joint_origin(self):
        '''
        Places links at the edge of their respective parents by setting their
        joint origin to their parents' lengths.
        For the posterior phalanx, all x, y and z attributes are set to place the fingers
        at the edges of the palm, based on their pre-populated random values.
        For the rest of the phalanges, x and y values are set to 0.
        '''
        for i in range(len(self.genome_data)):  # loop through fingers
            finger = self.genome_data[i]

            if np.all(finger == 0):
                # No need to continue looping as the rest of array elements will be None
                break

            parent_dim_z = self.__get_robot_palm_dims['z']  # height of the palm link

            for j in range(len(finger)):  # loop through phalanges
                phalanx = self.genome_data[i][j]

                if np.all(phalanx == 0):
                    break

                assert len(phalanx) == len(GeneDesc)

                # Attach link at the end of parent
                phalanx[GeneDesc.JOINT_ORIGIN_Z] = parent_dim_z

                parent_dim_z = phalanx[GeneDesc.DIM_Z]

                if j == 0:
                    # Limit the range of joint origin x and y to the area of the palm
                    palm_dim_x = float(self.__get_robot_palm_dims['x']) / 2
                    palm_dim_y = float(self.__get_robot_palm_dims['y']) / 2

                    phalanx_dim_x = normalize(
                        phalanx[GeneDesc.JOINT_ORIGIN_X], -palm_dim_x, palm_dim_x
                    )
                    phalanx_dim_y = normalize(
                        phalanx[GeneDesc.JOINT_ORIGIN_Y], -palm_dim_y, palm_dim_y
                    )

                    # Calculate normal to get sign of random location
                    x_quadrant = phalanx_dim_x / np.abs(phalanx_dim_x)
                    y_quadrant = phalanx_dim_y / np.abs(phalanx_dim_y)

                    # Get intersection point between palm edges and the random point in the
                    # palm. This moves the finger attachments to the edges while
                    # maintaining randomness
                    new_phalanx_dim_x, new_phalanx_dim_y = random.choice(
                        [
                            [phalanx_dim_x, palm_dim_y * y_quadrant],
                            [palm_dim_x * x_quadrant, phalanx_dim_y],
                        ]
                    )

                    phalanx[GeneDesc.JOINT_ORIGIN_X] = new_phalanx_dim_x
                    phalanx[GeneDesc.JOINT_ORIGIN_Y] = new_phalanx_dim_y

                else:
                    # Other phalanges are attached to the center of their parent phalanx
                    phalanx[GeneDesc.JOINT_ORIGIN_X] = 0
                    phalanx[GeneDesc.JOINT_ORIGIN_Y] = 0

    @property
    def __get_robot_palm_dims(self):
        '''
        Returns a dictionary of base robots hand's palm dimensions

        Returns:
            {x: , y: , z: }
        '''
        assert self.robot_hand_file is not None

        if not os.path.exists(self.robot_hand_file):
            raise FileNotFoundError('Can not read the robot base urdf file.')

        robot = ET.parse(self.robot_hand_file)
        root = robot.getroot()
        palm_link_size = root.find('link[@name="palm_link"]/visual/geometry/box')

        try:
            palm_link_size = palm_link_size.attrib['size']
        except Exception as e:
            print(e)
            return {'x': 0, 'y': 0, 'z': 0.1}  # fall back incase of error

        size_arr = palm_link_size.split(' ')

        return {
            'x': size_arr[0],
            'y': size_arr[1],
            'z': size_arr[2],
        }


class BrainPhenome:
    '''
    Interprets genome brain array to a neural network that can be trained

    Args:
        fingers_genome: fingers genome matrix
        brain_genome: brain genome array
    '''

    def __init__(
        self,
        fingers_genome,
        brain_genome,
        no_of_inputs=638,
        layers=[52, 52, 52],
        no_of_outputs=70,
    ):
        self.fingers_genome = fingers_genome
        self.brain_genome = brain_genome
        self.no_of_inputs = no_of_inputs
        self.layers = layers
        self.no_of_outputs = no_of_outputs

        self.model = nn.Sequential(
            nn.Linear(638, 52),
            nn.ReLU(),
            nn.Linear(52, 52),
            nn.ReLU(),
            nn.Linear(52, 52),
            nn.ReLU(),
            nn.Linear(52, 70),
        )
        self.loss = nn.MSELoss()
        self.optimizer = optim.SGD(self.model.parameters(), lr=0.001)
        self.epochs = 10

        # self.contact_distances = []  # Distance of each phalanx from target object

    def train(
        self,
        object_loc,
        object_class,
        action,
        apply_rotation_angles,
        fingers_genome=None,
    ):
        '''
        Args:
            object_loc (list): bounding box or target object. Shape = (2, 3)
            object_class (int): class for the target object. Starts from 1
            action (integer): pick up or drop object, either 1 or 2, respectively
            apply_rotation_angles (function): a callback function to send rotation
                angles to the specimen. Returns the fingers' distance from
                the target object after the angles have been applied
            fingers_genome (numpy array): genome encoding for fingers
        '''
        if fingers_genome is None:
            fingers_genome = self.fingers_genome

        input = self.__flatten_input(object_loc, object_class, action, fingers_genome)

        # Import the genome to the model
        self.__genome_to_model(self.brain_genome, self.model)

        # Train brain.
        # Duding the raining process, the brain sends phalanges rotation output and
        # receives their contact distances with the target object as to use in the
        # loss function
        for _ in range(self.epochs):
            self.model.train()

            # Calculate the rotation angle for each phalanx
            pred_angles = self.model(input)

            # Send calculated rotation angles to the specimen
            contact_distances = apply_rotation_angles(pred_angles.tolist())

            loss = self.__loss_fn(contact_distances)

            self.optimizer.zero_grad()

            loss.backward()
            self.optimizer.step()

    def move_object(self, object_loc, object_class, action, fingers_genome):
        input = self.__flatten_input(object_loc, object_class, action, fingers_genome)
        output = self.model(input)
        return output.tolist()

    def save_model(self, file_path):
        '''Saves model parameters to disk'''
        if not os.path.exists(file_path):
            raise FileNotFoundError('Make sure the directories in the path exist.')

        torch.save(self.model, file_path)

    def load_model(self, file_path):
        '''Loads model parameters from disk'''
        if not os.path.exists(file_path):
            raise FileNotFoundError('Could not load model from the specified path')

        self.model.load_state_dict(torch.load(file_path))
        self.model.eval()

    # def set_contact_distances(self, contact_distances):
    #     self.contact_distances = contact_distances

    def __loss_fn(self, contact_distances):
        '''
        Custom loss function. The outputs from the neural network are rotation angles.
        But the only feedback we get when the outputs are applied to the fingers is the
        distance of the object from the fingers. Hence, we can not use a normal loss
        function that calculates loss(output_angles, target_angles).
        This custom loss function takes each phalanx's distance from the target object
        and returns a scalar loss tensor. The final goal is to get the distances from
        the target object to zero.

        Args:
            contact_distance (list(float)): list of distance of phalanges from the target
                            object. This is calculated from PyBullet's getContactPoints

        Returns:
            scalar loss tensor
        '''
        assert isinstance(contact_distances, list)
        assert len(contact_distances) > 0

        dis_tensor = torch.tensor(contact_distances, requires_grad=True)

        # Calculate mean squared error, but we do not subtract the target distance
        # as we want them to be zero
        loss = torch.mean(dis_tensor**2)
        return loss

    def __genome_to_model(self, genome_array, model):
        '''
        Imports genome array to model. First converts genome list of numpy arrays
        to torch arrays which can be imported to the model
        '''
        model_params = list(model.parameters())
        for i in range(len(genome_array)):
            model_params[i].data = torch.tensor(genome_array[i])

    def __model_to_genome(self, model):
        '''
        Converts model weights and biases to genome array
        Source: https://stackoverflow.com/questions/50935345/understanding-torch-nn-parameter
        '''
        model_params = list(model.parameters())
        return [param.detach().numpy() for param in model_params]

    def __flatten_input(self, object_loc, object_class, action, fingers_genome):
        '''
        Flattens our multiple type and shape inputs to one dimensional torch array
        '''
        assert isinstance(object_loc, list)
        assert len(object_loc) == 2
        assert len(object_loc[0]) == 3
        object_loc_np = np.array(object_loc)
        object_loc_np = np.reshape(object_loc_np, (np.prod(object_loc_np.shape),))

        assert isinstance(object_class, int)
        object_class = np.array([object_class])

        assert isinstance(action, int)
        action = np.array([action])

        assert isinstance(fingers_genome, np.ndarray)
        fingers_genome = np.reshape(fingers_genome, (np.prod(fingers_genome.shape),))

        flat_np_array = np.concatenate(
            (object_loc_np, object_class, action, fingers_genome)
        )

        return torch.from_numpy(flat_np_array)
