import os
import xml.etree.ElementTree as ET
import random
import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim

from constants import GeneDesc, Limits
from helpers.math_functions import normalize


class FingersPhenome:
    '''
    Phenotype description for the fingers.
    This is where encoded genetic information is modified to suit the traits we want
    the fingers to have. For example, each phalanx will be connected at the end of its parent. This
    class handles that modification.
    '''

    def __init__(self, genome_data, gene_description, robot_hand_file):
        '''
        Args:
            genome_data: random genome generated by Genome class
            gene_description: GeneDesc enum class
            robot_hand_file: the base robot hand where dimensions for the palm are taken
        '''
        self.genome_data = genome_data
        self.gene_desc = gene_description
        self.robot_hand_file = robot_hand_file

    def get_genome(self):
        # modify genome
        self.__set_link_dimensions()
        self.__set_joint_origin()

        return self.genome_data

    def __set_link_dimensions(self):
        '''
        Limit the lower and upper dimensions of the phalanx.
        Takes the values from predefined constants.
        '''
        for i in range(len(self.genome_data)):  # loop through fingers
            finger = self.genome_data[i]

            if np.all(finger == 0):
                # No need to continue looping as the rest of array elements will be zero
                break

            for j in range(len(finger)):  # loop through phalanges
                phalanx = self.genome_data[i][j]

                if np.all(phalanx == 0):
                    break

                assert len(phalanx) == len(GeneDesc)

                phalanx[GeneDesc.DIM_X] = normalize(
                    phalanx[GeneDesc.DIM_X], Limits.DIM_X_LOWER, Limits.DIM_X_UPPER
                )
                phalanx[GeneDesc.DIM_Y] = normalize(
                    phalanx[GeneDesc.DIM_Y], Limits.DIM_Y_LOWER, Limits.DIM_Y_UPPER
                )
                phalanx[GeneDesc.DIM_Z] = normalize(
                    phalanx[GeneDesc.DIM_Z], Limits.DIM_Z_LOWER, Limits.DIM_Z_UPPER
                )

    def __set_joint_origin(self):
        '''
        Places links at the edge of their respective parents by setting their
        joint origin to their parents' lengths.
        For the posterior phalanx, all x, y and z attributes are set to place the fingers
        at the edges of the palm, based on their pre-populated random values.
        For the rest of the phalanges, x and y values are set to 0.
        '''
        for i in range(len(self.genome_data)):  # loop through fingers
            finger = self.genome_data[i]

            if np.all(finger == 0):
                # No need to continue looping as the rest of array elements will be None
                break

            parent_dim_z = self.__get_robot_palm_dims['z']  # height of the palm link

            for j in range(len(finger)):  # loop through phalanges
                phalanx = self.genome_data[i][j]

                if np.all(phalanx == 0):
                    break

                assert len(phalanx) == len(GeneDesc)

                # Attach link at the end of parent
                phalanx[GeneDesc.JOINT_ORIGIN_Z] = parent_dim_z

                parent_dim_z = phalanx[GeneDesc.DIM_Z]

                if j == 0:
                    # Limit the range of joint origin x and y to the area of the palm
                    palm_dim_x = float(self.__get_robot_palm_dims['x']) / 2
                    palm_dim_y = float(self.__get_robot_palm_dims['y']) / 2

                    phalanx_dim_x = normalize(
                        phalanx[GeneDesc.JOINT_ORIGIN_X], -palm_dim_x, palm_dim_x
                    )
                    phalanx_dim_y = normalize(
                        phalanx[GeneDesc.JOINT_ORIGIN_Y], -palm_dim_y, palm_dim_y
                    )

                    # Calculate normal to get sign of random location
                    x_quadrant = phalanx_dim_x / np.abs(phalanx_dim_x)
                    y_quadrant = phalanx_dim_y / np.abs(phalanx_dim_y)

                    # Get intersection point between palm edges and the random point in the
                    # palm. This moves the finger attachments to the edges while
                    # maintaining randomness
                    new_phalanx_dim_x, new_phalanx_dim_y = random.choice(
                        [
                            [phalanx_dim_x, palm_dim_y * y_quadrant],
                            [palm_dim_x * x_quadrant, phalanx_dim_y],
                        ]
                    )

                    phalanx[GeneDesc.JOINT_ORIGIN_X] = new_phalanx_dim_x
                    phalanx[GeneDesc.JOINT_ORIGIN_Y] = new_phalanx_dim_y

                else:
                    phalanx[GeneDesc.JOINT_ORIGIN_X] = 0
                    phalanx[GeneDesc.JOINT_ORIGIN_Y] = 0

    @property
    def __get_robot_palm_dims(self):
        '''
        Returns a dictionary of base robots hand's palm dimensions
        Return:
            {x: , y: , z: }
        '''
        assert self.robot_hand_file is not None

        if not os.path.exists(self.robot_hand_file):
            raise FileNotFoundError('Can not read the robot base urdf file.')

        robot = ET.parse(self.robot_hand_file)
        root = robot.getroot()
        palm_link_size = root.find('link[@name="palm_link"]/visual/geometry/box')

        try:
            palm_link_size = palm_link_size.attrib['size']
        except Exception as e:
            print(e)
            return {'x': 0, 'y': 0, 'z': 0.1}  # fall back incase of error

        size_arr = palm_link_size.split(' ')

        return {
            'x': size_arr[0],
            'y': size_arr[1],
            'z': size_arr[2],
        }


class BrainPhenome:
    '''
    Interprets genome brain array to a neural network that can be trained
    '''

    def __init__(
        self, genome_array, no_of_inputs=638, layers=[52, 52, 52], no_of_outputs=70
    ):
        self.genome_array = genome_array
        self.no_of_inputs = no_of_inputs
        self.layers = layers
        self.no_of_outputs = no_of_outputs

        self.model = nn.Sequential(
            nn.Linear(638, 52),
            nn.ReLU(),
            nn.Linear(52, 52),
            nn.ReLU(),
            nn.Linear(52, 52),
            nn.ReLU(),
            nn.Linear(52, 52),
            nn.ReLU(),
            nn.Linear(52, 70),
        )
        self.loss = nn.MSELoss()
        self.optimizer = optim.SGD(self.model.parameters(), lr=0.001)
        self.epochs = 10

        self.contact_distances = [] # Distance of each phalanx from target object

    def train(self, object_loc, object_class, action, fingers_genome=None):
        '''
        Args:
            object_loc (list): bounding box or target object. Shape = (2, 3)
            object_class (int): class for the target object. Starts from 1
            action (integer): pick up or drop object, either 1 or 2, respectively
            fingers_genome (numpy array): genome encoding for fingers
        '''
        if fingers_genome is None:
            fingers_genome = self.genome_array

        input = self.__flatten_input(object_loc, object_class, action, fingers_genome)

        # Import the genome to the model
        self.__genome_to_model()

        for _ in range(self.epochs):
            self.model.train()

            # Calculate the rotation angle for each phalanx
            pred_angles = self.model(input)

            loss = self.__loss_fn(self.contact_distances)

            self.optimizer.zero_grad()

            loss.backward()
            self.optimizer.step()

    def move_object(self, object_loc, object_class, action, fingers_genome):
        input = self.__flatten_input(object_loc, object_class, action, fingers_genome)
        output = self.model(input)
        return output.tolist()

    def save_model(self, file_path):
        if not os.path.exists(file_path):
            raise FileNotFoundError('Make sure the directories in the path exist.')

        torch.save(self.model, file_path)

    def load_model(self, file_path):
        if not os.path.exists(file_path):
            raise FileNotFoundError('Could not load model from the specified path')

        self.model.load_state_dict(torch.load(file_path))
        self.model.eval()
    
    def set_contact_distances(self, contact_distances):
        self.contact_distances = contact_distances

    def __loss_fn(self, contact_distances):
        '''
        Custom loss function. The outputs from the neural network are rotation angles.
        But the only feedback we get when the outputs are applied to the fingers is the
        distance of the object from the fingers. Hence, we can not use a normal loss
        function that calculates loss(output_angles, target_angles).
        This custom loss function takes each phalanx's distance from the target object
        and returns a scalar loss tensor. The final goal is to get the distances from
        the target object to zero.

        Args:
            contact_distance (list(float)): list of distance of phalanges from the target
                            object. This is calculated from PyBullet's getContactPoints
        
        Returns:
            scalar loss tensor
        '''
        assert isinstance(contact_distances, list)
        assert len(contact_distances) > 0

        dis_tensor = torch.tensor(contact_distances)

        # Calculate mean squared error, but we do not subtract the target distance
        # as we want them to be zero
        loss = torch.mean(dis_tensor**2)
        return loss

    def __genome_to_model(self):
        '''
        Imports genome array to model. First converts genome list of numpy arrays
        to torch arrays which can be imported to the model
        '''
        model_params = list(self.model.parameters())
        for i in range(len(self.genome_array)):
            model_params[i].data = torch.tensor(self.genome_array[i])

    def __flatten_input(self, object_loc, object_class, action, fingers_genome):
        '''
        Flattens our multiple type and shape inputs to one dimensional torch array
        '''
        assert isinstance(object_loc, np.ndarray)
        object_loc = np.reshape(object_loc, (np.prod(object_loc.shape),))

        assert isinstance(object_class, int)
        object_class = np.array([object_class])

        assert isinstance(action, int)
        action = np.array([action])

        assert isinstance(fingers_genome, np.ndarray)
        fingers_genome = np.reshape(fingers_genome, (np.prod(fingers_genome.shape),))

        flat_np_array = np.concatenate((object_loc, object_class, action, fingers_genome))

        return torch.from_numpy(flat_np_array)


# from genome import FingersGenome, BrainGenome
# fin_genome = FingersGenome(GeneDesc).get_genome()
# fin_phenome = FingersPhenome(fin_genome, GeneDesc, 'robot_hand.urdf').get_genome()
# brain_genome = BrainGenome().get_genome()
# brain_phenome = BrainPhenome(brain_genome)

# object_loc = np.array([[1, 2], [3, 4]])
# object_class = np.array(1)
# action = np.array(1)
# print(brain_phenome.flatten_input(object_loc, 1, 1, fin_phenome))