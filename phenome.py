import os
import xml.etree.ElementTree as ET
import random
import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim

import constants as c
from constants import GeneDesc, Limits
from helpers.math_functions import normalize
from genome import BrainGenome, FingersGenome


class FingersPhenome:
    '''
    Phenotype description for the fingers.
    This is where encoded genetic information is modified to suit the traits we want
    the fingers to have. For example, each phalanx will be connected at the end of its parent. This
    class handles that modification.

    Args:
        genome_data: random genome generated by Genome class
        gene_description: GeneDesc enum class
        robot_hand_file: the base robot hand where dimensions for the palm are taken
    '''

    def __init__(self, genome_data, gene_description, robot_hand_file):
        self.genome_data = genome_data
        self.gene_desc = gene_description
        self.robot_hand_file = robot_hand_file

    def get_genome(self):
        '''Returns a modified fingers genome matrix'''
        self.__modify_genome()

        return self.genome_data

    def __modify_genome(self):
        '''Modify values of the default random genome array'''

        for i in range(len(self.genome_data)):  # loop through fingers
            finger = self.genome_data[i]

            if np.all(finger == 0):
                # No need to continue looping as the rest of array elements will be zero
                break

            parent_dim_z = self.__get_robot_palm_dims['z']  # height of the palm link

            for j in range(len(finger)):  # loop through phalanges
                phalanx = self.genome_data[i][j]

                if np.all(phalanx == 0):
                    break

                assert len(phalanx) == len(GeneDesc)

                self.__set_link_dimensions(phalanx)

                new_parent_dim_z = self.__set_joint_origin(phalanx, parent_dim_z, j)
                parent_dim_z = new_parent_dim_z

                self.__set_joint_axis(phalanx, j)

    def __set_link_dimensions(self, phalanx):
        '''
        Limit the lower and upper dimensions of the phalanx.
        Takes the values from predefined constants.
        '''

        phalanx[GeneDesc.DIM_X] = normalize(
            phalanx[GeneDesc.DIM_X], Limits.DIM_X_LOWER, Limits.DIM_X_UPPER
        )
        phalanx[GeneDesc.DIM_Y] = normalize(
            phalanx[GeneDesc.DIM_Y], Limits.DIM_Y_LOWER, Limits.DIM_Y_UPPER
        )
        phalanx[GeneDesc.DIM_Z] = normalize(
            phalanx[GeneDesc.DIM_Z], Limits.DIM_Z_LOWER, Limits.DIM_Z_UPPER
        )

    def __set_joint_origin(self, phalanx, parent_dim_z, index):
        '''
        Places links at the edge of their respective parents by setting their
        joint origin to their parents' lengths.
        For the posterior phalanx, all x, y and z attributes are set to place the fingers
        at the edges of the palm, based on their pre-populated random values.
        For the rest of the phalanges, x and y values are set to 0.
        '''

        # Attach link at the end of parent
        phalanx[GeneDesc.JOINT_ORIGIN_Z] = parent_dim_z

        if index == 0:
            # Limit the range of joint origin x and y to the area of the palm
            palm_dim_x = float(self.__get_robot_palm_dims['x']) / 2
            palm_dim_y = float(self.__get_robot_palm_dims['y']) / 2

            phalanx_dim_x = normalize(
                phalanx[GeneDesc.JOINT_ORIGIN_X], -palm_dim_x, palm_dim_x
            )
            phalanx_dim_y = normalize(
                phalanx[GeneDesc.JOINT_ORIGIN_Y], -palm_dim_y, palm_dim_y
            )

            # Get sign of random location to get its quadrant
            x_quadrant = np.sign(phalanx_dim_x)
            y_quadrant = np.sign(phalanx_dim_y)

            # Get intersection point between palm edges and the random point in the
            # palm. This moves the finger attachments to the edges while
            # maintaining randomness
            new_phalanx_dim_x, new_phalanx_dim_y = random.choice(
                [
                    [phalanx_dim_x, palm_dim_y * y_quadrant],
                    [palm_dim_x * x_quadrant, phalanx_dim_y],
                ]
            )

            phalanx[GeneDesc.JOINT_ORIGIN_X] = new_phalanx_dim_x
            phalanx[GeneDesc.JOINT_ORIGIN_Y] = new_phalanx_dim_y

        else:
            # Other phalanges are attached to the center of their parent phalanx
            phalanx[GeneDesc.JOINT_ORIGIN_X] = 0
            phalanx[GeneDesc.JOINT_ORIGIN_Y] = 0

        return phalanx[GeneDesc.DIM_Z]

    def __set_joint_axis(self, phalanx, index):
        if index == 0:
            # The axis of rotation for the posterior phalanges should always
            # face the center of the palm. This is to ensure the fingers can
            # close and open

            palm_dim_x = float(self.__get_robot_palm_dims['x']) / 2
            palm_dim_y = float(self.__get_robot_palm_dims['y']) / 2

            # Check which edge of palm the phalanx is located
            if np.abs(phalanx[GeneDesc.JOINT_ORIGIN_X]) == np.abs(palm_dim_x):
                edge_sign = np.sign(phalanx[GeneDesc.JOINT_ORIGIN_X])
                phalanx[GeneDesc.JOINT_AXIS_X] = 0
                phalanx[GeneDesc.JOINT_AXIS_Y] = edge_sign
            else:
                edge_sign = np.sign(phalanx[GeneDesc.JOINT_ORIGIN_Y])
                phalanx[GeneDesc.JOINT_AXIS_X] = -1 * edge_sign
                phalanx[GeneDesc.JOINT_AXIS_Y] = 0

        else:
            # For the rest of the phalanges, choose rotation axis based
            # on the sum of the random values
            # I have chosen the values to spread out the rotational axis
            # with ratio 2:2:1 in respect to rotation in x, rotation in y
            # and rotation both in x and y respectively.
            axis_x_ran = phalanx[GeneDesc.JOINT_AXIS_X]
            axis_y_ran = phalanx[GeneDesc.JOINT_AXIS_Y]

            if axis_x_ran + axis_y_ran < 0.8:
                phalanx[GeneDesc.JOINT_AXIS_X] = 1
                phalanx[GeneDesc.JOINT_AXIS_Y] = 0
            elif axis_x_ran + axis_y_ran < 1.6:
                phalanx[GeneDesc.JOINT_AXIS_X] = 0
                phalanx[GeneDesc.JOINT_AXIS_Y] = 1
            else:
                phalanx[GeneDesc.JOINT_AXIS_X] = 1
                phalanx[GeneDesc.JOINT_AXIS_Y] = 1

        # For now we doesn't need the phalanges to revolve around the z axis
        phalanx[GeneDesc.JOINT_AXIS_Z] = 0

    @property
    def __get_robot_palm_dims(self):
        '''
        Returns a dictionary of base robots hand's palm dimensions

        Returns:
            {x: , y: , z: }
        '''
        assert self.robot_hand_file is not None

        if not os.path.exists(self.robot_hand_file):
            raise FileNotFoundError('Can not read the robot base urdf file.')

        robot = ET.parse(self.robot_hand_file)
        root = robot.getroot()
        palm_link_size = root.find('link[@name="palm_link"]/visual/geometry/box')

        try:
            palm_link_size = palm_link_size.attrib['size']
        except Exception as e:
            print(e)
            return {'x': 0, 'y': 0, 'z': 0.1}  # fall back incase of error

        size_arr = palm_link_size.split(' ')

        return {
            'x': size_arr[0],
            'y': size_arr[1],
            'z': size_arr[2],
        }


class BrainPhenome:
    '''
    Interprets genome brain array to a neural network that can be trained

    Args:
        brain_genome: brain genome object
    '''

    def __init__(self, brain_genome: BrainGenome):
        assert isinstance(brain_genome, BrainGenome)

        self.brain_genome_array = brain_genome.get_genome()
        self.brain_genome_shape = brain_genome.get_genome_shape()

        # Create layers based on the brain genome shape
        # Source: https://discuss.pytorch.org/t/how-to-create-mlp-model-with-arbitrary-number-of-hidden-layers/13124/6

        # self.model_layers = nn.ModuleList()
        # for shape in brain_genome.get_genome_shape():
        #     if len(shape) == 2:  # neural layer
        #         self.model_layers.append(nn.Linear(*shape))
        #     self.model_layers.append(nn.ReLU())  # activation
        # self.model_layers.pop(-1)  # Remove activation from output layer

        self.model_layers = nn.ModuleList()
        for shape in brain_genome.get_genome_shape():
            if len(shape) == 2:  # neural layer
                self.model_layers.append(nn.Linear(*shape))
            self.model_layers.append(nn.ReLU())  # activation
        self.model_layers.pop(-1)  # Remove activation from output layer

    def move(self, input):
        '''Returns rotation angle based on input

        Args:
            input (list): [
                distance of phalanx from target object,
                rotation in x axis (0/1),
                rotation in y axis (0/1),
                rotation in z axis (0/1),
                phalanx center of mass distance from palm
            ]
        '''

        assert isinstance(input, list)
        assert len(input) == c.NUMBER_OF_INPUTS

        output = torch.tensor(input, dtype=torch.float32)

        for model in self.model_layers:
            output = model(output)

        return output

    def save_model(self, file_path):
        '''Saves model parameters to disk'''
        if ('/' in file_path) and (not os.path.exists(file_path)):
            raise FileNotFoundError('Make sure the directories in the path exist.')

        torch.save(self.model_layers, file_path)

    def load_model(self, file_path):
        '''Loads model parameters from disk'''
        if not os.path.exists(file_path):
            raise FileNotFoundError('Could not load model from the specified path')

        self.model_layers = torch.load(file_path)


# genome = BrainGenome()
# print(genome.get_genome())
# phenome = BrainPhenome(genome)
# print(phenome.move([1.2, 1, 0, 0, 2.7]))
# phenome.save_model('test_2.pt')
# phenome.load_model('test_2.pt')
# print(phenome.move([1.2, 1, 0, 0, 2.7]))

# genome = FingersGenome(GeneDesc).get_genome()
# print(genome)
# phenome = FingersPhenome(genome, GeneDesc, 'robot_hand.urdf')
# print(phenome.get_genome())
