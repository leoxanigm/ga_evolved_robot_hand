import os
import xml.etree.ElementTree as ET
import random
import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
import pickle

import constants as c
from constants import GeneDesc, Limits
from helpers.math_functions import normalize
from genome import BrainGenome, FingersGenome


class FingersPhenome:
    '''
    Phenotype description for the fingers.
    This is where encoded genetic information is modified to suit the traits we want
    the fingers to have. For example, each phalanx will be connected at the end of its parent. This
    class handles that modification.

    Args:
        genome_matrix: random genome generated by Genome class
        gene_description: GeneDesc enum class
        robot_hand_file: the base robot hand where dimensions for the palm are taken
    '''

    def __init__(
        self,
        robot_hand_file: str,
        fingers_genome: FingersGenome = None,
    ):
        self.robot_hand_file = robot_hand_file

        if fingers_genome:
            self.genome_matrix = fingers_genome.genome
            self.__modify_genome(self.genome_matrix)

    def save_genome(self, file_path: str):
        '''Saves genome matrix to disk'''

        if self.genome_matrix is None:
            raise RuntimeError(
                'Finger genome matrix needs to be loaded before it can be accessed'
            )

        with open(file_path, 'wb') as f:
            pickle.dump(self.genome_matrix, f)

    def load_genome(self, file_path: str) -> np.ndarray:
        '''Loads genome matrix from disk'''
        if not os.path.exists(file_path):
            raise FileNotFoundError(
                'Could not load genome matrix from the specified path'
            )

        with open(file_path, 'rb') as f:
            genome_matrix = pickle.load(f)
            self.genome_matrix = genome_matrix

        return self.genome_matrix

    def __modify_genome(self, genome_matrix: np.ndarray):
        '''Modify values of the default random genome array'''

        for i in range(len(genome_matrix)):  # loop through fingers
            finger = genome_matrix[i]

            if np.all(finger == 0):
                # No need to continue looping as the rest of array elements will be zero
                break

            parent_dim_z = self.__get_robot_palm_dims['z']  # height of the palm link

            for j in range(len(finger)):  # loop through phalanges
                phalanx = genome_matrix[i][j]

                if np.all(phalanx == 0):
                    break

                assert len(phalanx) == len(GeneDesc)

                # Modify link dimensions
                self.__set_link_dimensions(phalanx)

                # Modify joint origin
                new_parent_dim_z = self.__set_joint_origin(phalanx, parent_dim_z, j)
                parent_dim_z = new_parent_dim_z

                # Modify joint axis
                self.__set_joint_axis(phalanx, j)

    def __set_link_dimensions(self, phalanx):
        '''
        Limit the lower and upper dimensions of the phalanx.
        Takes the values from predefined constants.
        '''

        phalanx[GeneDesc.DIM_X] = normalize(
            phalanx[GeneDesc.DIM_X], Limits.DIM_X_LOWER, Limits.DIM_X_UPPER
        )
        phalanx[GeneDesc.DIM_Y] = normalize(
            phalanx[GeneDesc.DIM_Y], Limits.DIM_Y_LOWER, Limits.DIM_Y_UPPER
        )
        phalanx[GeneDesc.DIM_Z] = normalize(
            phalanx[GeneDesc.DIM_Z], Limits.DIM_Z_LOWER, Limits.DIM_Z_UPPER
        )

    def __set_joint_origin(self, phalanx, parent_dim_z, index):
        '''
        Places links at the edge of their respective parents by setting their
        joint origin to their parents' lengths.
        For the posterior phalanx, all x, y and z attributes are set to place the fingers
        at the edges of the palm, based on their pre-populated random values.
        For the rest of the phalanges, x and y values are set to 0.
        '''

        # Attach link at the end of parent
        phalanx[GeneDesc.JOINT_ORIGIN_Z] = parent_dim_z

        if index == 0:
            # Limit the range of joint origin x and y to the area of the palm
            palm_dim_x = float(self.__get_robot_palm_dims['x']) / 2
            palm_dim_y = float(self.__get_robot_palm_dims['y']) / 2

            phalanx_dim_x = normalize(
                phalanx[GeneDesc.JOINT_ORIGIN_X], -palm_dim_x, palm_dim_x
            )
            phalanx_dim_y = normalize(
                phalanx[GeneDesc.JOINT_ORIGIN_Y], -palm_dim_y, palm_dim_y
            )

            # Get sign of random location to get its quadrant
            x_quadrant = np.sign(phalanx_dim_x)
            y_quadrant = np.sign(phalanx_dim_y)

            # Get intersection point between palm edges and the random point in the
            # palm. This moves the finger attachments to the edges while
            # maintaining randomness
            new_phalanx_dim_x, new_phalanx_dim_y = random.choice(
                [
                    [phalanx_dim_x, palm_dim_y * y_quadrant],
                    [palm_dim_x * x_quadrant, phalanx_dim_y],
                ]
            )

            phalanx[GeneDesc.JOINT_ORIGIN_X] = new_phalanx_dim_x
            phalanx[GeneDesc.JOINT_ORIGIN_Y] = new_phalanx_dim_y

        else:
            # Other phalanges are attached to the center of their parent phalanx
            phalanx[GeneDesc.JOINT_ORIGIN_X] = 0
            phalanx[GeneDesc.JOINT_ORIGIN_Y] = 0

        return phalanx[GeneDesc.DIM_Z]

    def __set_joint_axis(self, phalanx, index):
        if index == 0:
            # The axis of rotation for the posterior phalanges should always
            # face the center of the palm. This is to ensure the fingers can
            # close and open

            palm_dim_x = float(self.__get_robot_palm_dims['x']) / 2
            palm_dim_y = float(self.__get_robot_palm_dims['y']) / 2

            # Check which edge of palm the phalanx is located
            if np.abs(phalanx[GeneDesc.JOINT_ORIGIN_X]) == np.abs(palm_dim_x):
                edge_sign = np.sign(phalanx[GeneDesc.JOINT_ORIGIN_X])
                phalanx[GeneDesc.JOINT_AXIS_X] = 0
                phalanx[GeneDesc.JOINT_AXIS_Y] = edge_sign
            else:
                edge_sign = np.sign(phalanx[GeneDesc.JOINT_ORIGIN_Y])
                phalanx[GeneDesc.JOINT_AXIS_X] = -1 * edge_sign
                phalanx[GeneDesc.JOINT_AXIS_Y] = 0

        else:
            # For the rest of the phalanges, choose rotation axis based
            # on the sum of the random values
            # I have chosen the values to spread out the rotational axis
            # with ratio 2:2:1 in respect to rotation in x, rotation in y
            # and rotation both in x and y respectively.
            axis_x_ran = phalanx[GeneDesc.JOINT_AXIS_X]
            axis_y_ran = phalanx[GeneDesc.JOINT_AXIS_Y]

            if axis_x_ran + axis_y_ran < 0.8:
                phalanx[GeneDesc.JOINT_AXIS_X] = 1
                phalanx[GeneDesc.JOINT_AXIS_Y] = 0
            elif axis_x_ran + axis_y_ran < 1.6:
                phalanx[GeneDesc.JOINT_AXIS_X] = 0
                phalanx[GeneDesc.JOINT_AXIS_Y] = 1
            else:
                phalanx[GeneDesc.JOINT_AXIS_X] = 1
                phalanx[GeneDesc.JOINT_AXIS_Y] = 1

        # For now we doesn't need the phalanges to revolve around the z axis
        phalanx[GeneDesc.JOINT_AXIS_Z] = 0

    @property
    def genome(self):
        '''Returns the modified fingers genome matrix'''

        if self.genome_matrix is None:
            raise RuntimeError(
                'Finger genome matrix needs to be loaded before it can be accessed'
            )

        return self.genome_matrix

    @property
    def __get_robot_palm_dims(self):
        '''
        Returns a dictionary of base robots hand's palm dimensions

        Returns:
            {x: , y: , z: }
        '''
        assert self.robot_hand_file is not None

        if not os.path.exists(self.robot_hand_file):
            raise FileNotFoundError('Can not read the robot base urdf file.')

        robot = ET.parse(self.robot_hand_file)
        root = robot.getroot()
        palm_link_size = root.find('link[@name="palm_link"]/visual/geometry/box')

        try:
            palm_link_size = palm_link_size.attrib['size']
        except Exception as e:
            print(e)
            return {'x': 0, 'y': 0, 'z': 0.1}  # fall back incase of error

        size_arr = palm_link_size.split(' ')

        return {
            'x': size_arr[0],
            'y': size_arr[1],
            'z': size_arr[2],
        }


class BrainPhenome:
    '''
    Interprets genome brain array to a neural network that can be trained

    Args:
        brain_genome: brain genome object
    '''

    def __init__(self, brain_genome: BrainGenome = None):
        self.model_layers = None
        self.brain_genome_array = None

        if brain_genome:
            self.brain_genome_array = brain_genome.genome
            self.__genome_to_model(self.brain_genome_array)

    def __genome_to_model(self, brain_genome_array: list[np.ndarray]):
        '''Creates a neural network model and loads weights and biases
        from the brain_genome_array to the model

        Args:
            brain_genome_array (list[np.ndarray]): brain genome array either
                randomly generated by BrainGenome or loaded from disk
        '''

        # Create layers based on the brain genome shape
        # Source: https://discuss.pytorch.org/t/how-to-create-mlp-model-with-arbitrary-number-of-hidden-layers/13124/6
        self.model_layers = nn.ModuleList()

        # The genome array contains values for weights and biases, we only
        # need the shape of the weights array for parameters of the Linear
        # model. Hence using a step of 2
        for i in range(0, len(brain_genome_array), 2):
            weights = brain_genome_array[i]
            biases = brain_genome_array[i + 1]

            model = nn.Linear(*weights.shape)
            activation = nn.ReLU()

            # Get parameter generator object
            params_generator = model.parameters()

            # Get model weights and biases
            model_weights = next(params_generator)
            model_biases = next(params_generator)

            assert tuple(model_weights.shape) == weights.T.shape
            assert tuple(model_biases.shape) == biases.shape

            # Torch internally transposes weights, we transpose the Numpy
            # weights array
            model_weights.data = torch.tensor(
                weights.T, requires_grad=True, dtype=torch.float32
            )
            model_biases.data = torch.tensor(
                biases, requires_grad=True, dtype=torch.float32
            )

            # Add neural layer and activation to the model list
            self.model_layers.append(model)
            self.model_layers.append(activation)

        self.model_layers.pop(-1)  # Remove activation from output layer

    def move(self, input):
        '''Returns rotation angle based on input

        Args:
            input (list): [
                distance of phalanx from target object,
                rotation in x axis (0/1),
                rotation in y axis (0/1),
                rotation in z axis (0/1),
                phalanx center of mass distance from palm
            ]
        '''

        assert isinstance(input, list)
        assert len(input) == c.NUMBER_OF_INPUTS

        output = torch.tensor(input, dtype=torch.float32)

        for model in self.model_layers:
            output = model(output)

        return output

    def save_genome(self, file_path: str):
        '''Saves model parameters to disk'''

        if self.brain_genome_array is None:
            raise RuntimeError('Brain genome needs to be loaded before saving model')

        with open(file_path, 'wb') as f:
            pickle.dump(self.brain_genome_array, f)

    def load_genome(self, file_path: str):
        '''Loads model parameters from disk'''
        if not os.path.exists(file_path):
            raise FileNotFoundError('Could not load model from the specified path')

        with open(file_path, 'rb') as f:
            brain_genome_array = pickle.load(f)
            self.brain_genome_array = brain_genome_array
            self.__genome_to_model(self.brain_genome_array)
