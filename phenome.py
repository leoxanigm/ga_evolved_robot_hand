import os
import xml.etree.ElementTree as ET
import random
import numpy as np

from constants import GeneDesc, Limits
from helpers.math_functions import normalize



class FingersPhenome:
    '''
    Phenotype description for the fingers.
    This is where encoded genetic information is modified to suit the traits we want
    the fingers to have. For example, each phalanx will be connected at the end of its parent. This
    class handles that modification.
    '''

    def __init__(self, genome_data, gene_description, robot_hand_file):
        '''
        Params:
            genome_data: random genome generated by Genome class
            gene_description: GeneDesc enum class
            robot_hand_file: the base robot hand where dimensions for the palm are taken
        '''
        self.genome_data = genome_data
        self.gene_desc = gene_description
        self.robot_hand_file = robot_hand_file

    def get_genome(self):
        # modify genome
        self.__set_link_dimensions()
        self.__set_joint_origin()

        return self.genome_data

    def __set_link_dimensions(self):
        '''
        Limit the lower and upper dimensions of the phalanx.
        Takes the values from predefined constants.
        '''
        for i in range(len(self.genome_data)):  # loop through fingers
            finger = self.genome_data[i]

            if np.all(finger == 0):
                # No need to continue looping as the rest of array elements will be zero
                break

            for j in range(len(finger)):  # loop through phalanges
                phalanx = self.genome_data[i][j]

                if np.all(phalanx == 0):
                    break

                assert len(phalanx) == len(GeneDesc)

                phalanx[GeneDesc.DIM_X] = normalize(
                    phalanx[GeneDesc.DIM_X], Limits.DIM_X_LOWER, Limits.DIM_X_UPPER
                )
                phalanx[GeneDesc.DIM_Y] = normalize(
                    phalanx[GeneDesc.DIM_Y], Limits.DIM_Y_LOWER, Limits.DIM_Y_UPPER
                )
                phalanx[GeneDesc.DIM_Z] = normalize(
                    phalanx[GeneDesc.DIM_Z], Limits.DIM_Z_LOWER, Limits.DIM_Z_UPPER
                )

    def __set_joint_origin(self):
        '''
        Places links at the edge of their respective parents by setting their
        joint origin to their parents' lengths.
        For the posterior phalanx, all x, y and z attributes are set to place the fingers
        at the edges of the palm, based on their pre-populated random values.
        For the rest of the phalanges, x and y values are set to 0.
        '''
        for i in range(len(self.genome_data)):  # loop through fingers
            finger = self.genome_data[i]

            if np.all(finger == 0):
                # No need to continue looping as the rest of array elements will be None
                break

            parent_dim_z = self.__get_robot_palm_dims['z']  # height of the palm link

            for j in range(len(finger)):  # loop through phalanges
                phalanx = self.genome_data[i][j]

                if np.all(phalanx == 0):
                    break

                assert len(phalanx) == len(GeneDesc)

                # Attach link at the end of parent
                phalanx[GeneDesc.JOINT_ORIGIN_Z] = parent_dim_z

                parent_dim_z = phalanx[GeneDesc.DIM_Z]

                if j == 0:
                    # Limit the range of joint origin x and y to the area of the palm
                    palm_dim_x = float(self.__get_robot_palm_dims['x']) / 2
                    palm_dim_y = float(self.__get_robot_palm_dims['y']) / 2

                    phalanx_dim_x = normalize(
                        phalanx[GeneDesc.JOINT_ORIGIN_X], -palm_dim_x, palm_dim_x
                    )
                    phalanx_dim_y = normalize(
                        phalanx[GeneDesc.JOINT_ORIGIN_Y], -palm_dim_y, palm_dim_y
                    )

                    # Calculate normal to get sign of random location
                    x_quadrant = phalanx_dim_x / np.abs(phalanx_dim_x)
                    y_quadrant = phalanx_dim_y / np.abs(phalanx_dim_y)

                    # Get intersection point between palm edges and the random point in the
                    # palm. This moves the finger attachments to the edges while
                    # maintaining randomness
                    new_phalanx_dim_x, new_phalanx_dim_y = random.choice(
                        [
                            [phalanx_dim_x, palm_dim_y * y_quadrant],
                            [palm_dim_x * x_quadrant, phalanx_dim_y],
                        ]
                    )

                    

                    phalanx[GeneDesc.JOINT_ORIGIN_X] = new_phalanx_dim_x
                    phalanx[GeneDesc.JOINT_ORIGIN_Y] = new_phalanx_dim_y

                else:
                    phalanx[GeneDesc.JOINT_ORIGIN_X] = 0
                    phalanx[GeneDesc.JOINT_ORIGIN_Y] = 0

    @property
    def __get_robot_palm_dims(self):
        '''
        Returns a dictionary of base robots hand's palm dimensions
        Return:
            {x: , y: , z: }
        '''
        assert self.robot_hand_file is not None

        if not os.path.exists(self.robot_hand_file):
            raise FileNotFoundError('Can not read the robot base urdf file.')

        robot = ET.parse(self.robot_hand_file)
        root = robot.getroot()
        palm_link_size = root.find('link[@name="palm_link"]/visual/geometry/box')

        try:
            palm_link_size = palm_link_size.attrib['size']
        except Exception as e:
            print(e)
            return {'x': 0, 'y': 0, 'z': 0.1}  # fall back incase of error

        size_arr = palm_link_size.split(' ')

        return {
            'x': size_arr[0],
            'y': size_arr[1],
            'z': size_arr[2],
        }


class BrainPhenome:
    pass