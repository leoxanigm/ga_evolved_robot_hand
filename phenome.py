import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
import pickle

import constants as c
from constants import GeneDesc, Limits
from genome import BrainGenome, FingersGenome
from helpers.math_functions import normalize
from helpers.misc_helpers import get_robot_palm_dims


class FingersPhenome:
    '''
    Phenotype description for the fingers.
    This is where encoded genetic information is modified to suit the traits
    we want the fingers to have. For example, each phalanx will be connected
    at the end of its parent. This class handles that modification.

    Args:
        genome_matrix:  genome generated by Genome class
    '''

    def __init__(self, fingers_genome: FingersGenome = None):
        self.genome_matrix = None
        self.phenome_matrix = None

        if fingers_genome:
            self.genome_matrix = fingers_genome.genome

            self.phenome_matrix = self.genome_matrix
            self.__modify_genome(self.phenome_matrix)

    def save_genome(self, file_path: str):
        '''Saves genome matrix to disk'''

        if self.genome_matrix is None:
            raise RuntimeError(
                'Genome matrix needs to be loaded before it can be accessed'
            )

        with open(file_path, 'wb') as f:
            pickle.dump(self.genome_matrix, f)

    def load_genome(self, file_path: str) -> np.ndarray:
        '''Loads genome matrix from disk'''
        if not os.path.exists(file_path):
            raise FileNotFoundError(
                'Could not load genome matrix from the specified path'
            )

        with open(file_path, 'rb') as f:
            genome_matrix = pickle.load(f)
            self.genome_matrix = genome_matrix

            self.phenome_matrix = self.genome_matrix
            self.__modify_genome(self.phenome_matrix)

        return self.phenome_matrix

    def __modify_genome(self, phenome_matrix: np.ndarray):
        '''Modify values of the default  genome array'''

        for i in range(len(phenome_matrix)):  # loop through fingers
            finger = phenome_matrix[i]

            if np.all(finger == 0):
                # No need to continue looping as the rest of array elements will be zero
                break

            dimensions = get_robot_palm_dims('robot_hand.urdf')
            parent_dim_z = dimensions['z']  # height of the palm link

            for j in range(len(finger)):  # loop through phalanges
                phalanx = phenome_matrix[i][j]

                if np.all(phalanx == 0):
                    break

                assert len(phalanx) == len(GeneDesc)

                # Modify link dimensions
                self.__set_link_dimensions(phalanx)

                # Modify joint origin
                new_parent_dim_z = self.__set_joint_origin(phalanx, parent_dim_z, j)
                parent_dim_z = new_parent_dim_z

                # Modify joint axis
                self.__set_joint_axis(phalanx, j)

    def __set_link_dimensions(self, phalanx):
        '''
        Limit the lower and upper dimensions of the phalanx.
        Takes the values from predefined constants.
        '''

        phalanx[GeneDesc.DIM_X] = normalize(
            phalanx[GeneDesc.DIM_X], Limits.DIM_X_LOWER, Limits.DIM_X_UPPER
        )
        phalanx[GeneDesc.DIM_Y] = normalize(
            phalanx[GeneDesc.DIM_Y], Limits.DIM_Y_LOWER, Limits.DIM_Y_UPPER
        )
        phalanx[GeneDesc.DIM_Z] = normalize(
            phalanx[GeneDesc.DIM_Z], Limits.DIM_Z_LOWER, Limits.DIM_Z_UPPER
        )

    def __set_joint_origin(self, phalanx, parent_dim_z, index):
        '''
        Places links at the edge of their respective parents by setting their
        joint origin to their parents' lengths.
        For the posterior phalanx, all x, y and z attributes are set to place the fingers
        at the edges of the palm, based on their pre-populated  values.
        For the rest of the phalanges, x and y values are set to 0.
        '''

        if index == 0:
            # Limit the range of joint origin x and y to the area of the palm
            dimensions = get_robot_palm_dims('robot_hand.urdf')
            palm_dim_x = float(dimensions['x']) / 2
            palm_dim_y = float(dimensions['y']) / 2

            phalanx_dim_x = normalize(
                phalanx[GeneDesc.JOINT_ORIGIN_X], -palm_dim_x, palm_dim_x
            )
            phalanx_dim_y = normalize(
                phalanx[GeneDesc.JOINT_ORIGIN_Y], -palm_dim_y, palm_dim_y
            )

            # Get sign of  location to get its quadrant
            x_quadrant = np.sign(phalanx_dim_x)
            y_quadrant = np.sign(phalanx_dim_y)

            # Get intersection point between palm edges and the  point in the
            # palm. This moves the finger attachments to the edges while
            # maintaining ness and order. The ness is chosen by
            # the value of joint origin in z axis. So for the same genome encoding,
            # we get the same attachment point each time.
            if phalanx[GeneDesc.JOINT_ORIGIN_Z] < 0.5:
                phalanx[GeneDesc.JOINT_ORIGIN_X] = phalanx_dim_x
                phalanx[GeneDesc.JOINT_ORIGIN_Y] = palm_dim_y * y_quadrant
            else:
                phalanx[GeneDesc.JOINT_ORIGIN_X] = palm_dim_x * x_quadrant
                phalanx[GeneDesc.JOINT_ORIGIN_Y] = phalanx_dim_y

        else:
            # Other phalanges are attached to the center of their parent phalanx
            phalanx[GeneDesc.JOINT_ORIGIN_X] = 0
            phalanx[GeneDesc.JOINT_ORIGIN_Y] = 0

        # Attach link at the end of parent
        phalanx[GeneDesc.JOINT_ORIGIN_Z] = parent_dim_z

        return phalanx[GeneDesc.DIM_Z]

    def __set_joint_axis(self, phalanx, index):
        if index == 0:
            # The axis of rotation for the posterior phalanges should always
            # face the center of the palm. This is to ensure the fingers can
            # close and open

            dimensions = get_robot_palm_dims('robot_hand.urdf')
            palm_dim_x = float(dimensions['x']) / 2
            palm_dim_y = float(dimensions['y']) / 2

            # Check which edge of palm the phalanx is located
            if np.abs(phalanx[GeneDesc.JOINT_ORIGIN_X]) == np.abs(palm_dim_x):
                edge_sign = np.sign(phalanx[GeneDesc.JOINT_ORIGIN_X])
                phalanx[GeneDesc.JOINT_AXIS_X] = 0
                phalanx[GeneDesc.JOINT_AXIS_Y] = edge_sign
            else:
                edge_sign = np.sign(phalanx[GeneDesc.JOINT_ORIGIN_Y])
                phalanx[GeneDesc.JOINT_AXIS_X] = -1 * edge_sign
                phalanx[GeneDesc.JOINT_AXIS_Y] = 0

        else:
            # For the rest of the phalanges, choose rotation axis based
            # on the sum of the  values
            # I have chosen the values to spread out the rotational axis
            # with ratio 2:2:1 in respect to rotation in x, rotation in y
            # and rotation both in x and y respectively.
            axis_x_ran = phalanx[GeneDesc.JOINT_AXIS_X]
            axis_y_ran = phalanx[GeneDesc.JOINT_AXIS_Y]

            if axis_x_ran + axis_y_ran < 0.8:
                phalanx[GeneDesc.JOINT_AXIS_X] = 1
                phalanx[GeneDesc.JOINT_AXIS_Y] = 0
            elif axis_x_ran + axis_y_ran < 1.6:
                phalanx[GeneDesc.JOINT_AXIS_X] = 0
                phalanx[GeneDesc.JOINT_AXIS_Y] = 1
            else:
                phalanx[GeneDesc.JOINT_AXIS_X] = 1
                phalanx[GeneDesc.JOINT_AXIS_Y] = 1

        # For now we doesn't need the phalanges to revolve around the z axis
        phalanx[GeneDesc.JOINT_AXIS_Z] = 0

    @property
    def genome(self):
        '''Returns the fingers genome matrix'''

        if self.genome_matrix is None:
            raise RuntimeError(
                'Genome matrix needs to be loaded before it can be accessed'
            )

        return self.genome_matrix

    @property
    def phenome(self):
        '''Returns the modified fingers phenome matrix'''

        if self.phenome_matrix is None:
            raise RuntimeError(
                'Finger genome matrix needs to be loaded before it can be accessed'
            )

        return self.phenome_matrix


class BrainPhenome:
    '''
    Interprets genome brain array to a neural network that can be trained

    Args:
        brain_genome: brain genome object
    '''

    def __init__(self, brain_genome: BrainGenome = None):
        self.model_layers = None
        self.brain_genome_array = None

        if brain_genome:
            self.brain_genome_array = brain_genome.genome
            self.__genome_to_model(self.brain_genome_array)

    def __genome_to_model(self, brain_genome_array: list[np.ndarray]):
        '''Creates a neural network model and loads weights and biases
        from the brain_genome_array to the model

        Args:
            brain_genome_array (list[np.ndarray]): brain genome array either
                ly generated by BrainGenome or loaded from disk
        '''

        # Create layers based on the brain genome shape
        # Source: https://discuss.pytorch.org/t/how-to-create-mlp-model-with-arbitrary-number-of-hidden-layers/13124/6
        self.model_layers = nn.ModuleList()

        # The genome array contains values for weights and biases, we only
        # need the shape of the weights array for parameters of the Linear
        # model. Hence using a step of 2
        for i in range(0, len(brain_genome_array), 2):
            weights = brain_genome_array[i]
            biases = brain_genome_array[i + 1]

            model = nn.Linear(*weights.shape)
            activation = nn.ReLU()

            # Get parameter generator object
            params_generator = model.parameters()

            # Get model weights and biases
            model_weights = next(params_generator)
            model_biases = next(params_generator)

            assert tuple(model_weights.shape) == weights.T.shape
            assert tuple(model_biases.shape) == biases.shape

            # Torch internally transposes weights, we transpose the Numpy
            # weights array
            model_weights.data = torch.tensor(
                weights.T, requires_grad=True, dtype=torch.float32
            )
            model_biases.data = torch.tensor(
                biases, requires_grad=True, dtype=torch.float32
            )

            # Add neural layer and activation to the model list
            self.model_layers.append(model)
            self.model_layers.append(activation)

        self.model_layers.pop(-1)  # Remove activation from output layer

    def move(self, input):
        '''Returns rotation angle based on input

        Args:
            input (list): [
                distance of phalanx from target object,
                rotation in x axis (0/1),
                rotation in y axis (0/1),
                rotation in z axis (0/1),
                phalanx center of mass distance from palm
            ]
        '''

        assert isinstance(input, list)
        assert len(input) == c.NUMBER_OF_INPUTS

        output = torch.tensor(input, dtype=torch.float32)

        for layer in self.model_layers:
            output = layer(output)

            # Get activations, this will later be used as a probability map
            # when weights and biases are crossed
            # if isinstance(layer, nn.ReLU):
            #     activations = output

        return output

    def save_genome(self, file_path: str):
        '''Saves model parameters to disk'''

        if self.brain_genome_array is None:
            raise RuntimeError('Brain genome needs to be loaded before saving model')

        with open(file_path, 'wb') as f:
            pickle.dump(self.brain_genome_array, f)

    def load_genome(self, file_path: str):
        '''Loads model parameters from disk'''
        if not os.path.exists(file_path):
            raise FileNotFoundError('Could not load model from the specified path')

        with open(file_path, 'rb') as f:
            brain_genome_array = pickle.load(f)
            self.brain_genome_array = brain_genome_array
            self.__genome_to_model(self.brain_genome_array)

    @property
    def genome(self):
        '''Returns the bran genome array'''

        if self.brain_genome_array is None:
            raise RuntimeError(
                'Genome array needs to be loaded before it can be accessed'
            )

        return self.brain_genome_array
